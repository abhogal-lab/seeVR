% Copyright (C) Alex A. Bhogal, 2021, University Medical Center Utrecht,
% a.bhogal@umcutrecht.nl
% <convHRF2: convolved an input signal with a double-gamma hemodynamic response function (HRF) >
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <https://www.gnu.org/licenses/>.
%
% ************************************************************************
% This function takes uses the supplied options (opts.onset, opts.disp,
% opts.under) to generate a series of hemodynamic response functions
% (HRFs). These HRFs are then convolved with the input probe.
%
% probe: input probe to be regressed with HRF
%
% opts: options structure containing required variables for this specific
% function; i.e. opts.plot, opts.rratio, opts.onset, opts.disp, opts.under
%
% HRF: an array of double-gamma functions produced by the corresponding
% input functions
%
% HRFidx: index associated with each HRF. This is used in the fitHRF
% function
%
% HRF_probe: an array consisting of normalized time-series' generated by
% convolving the input probe with the HRF functions. The first vector entry
% is the normalized (0-1) probe.
function [HRFidx, HRF_probe] = convHRF2(probe, opts)

warning('off')
global opts;
%set defaults
if isfield(opts,'verbose'); else; opts.verbose = 0; end %turn plotting on or off
if isfield(opts,'rratio'); else; opts.rratio = 1000; end %seems to affect the vertical spread of HRF (use large value to limit)
if isfield(opts,'onset'); else; opts.onset = 1; end %parameter that defines response onset
if isfield(opts,'disp'); else; opts.disp = [1:.5:30]; end %dispersion parameter - set a default vector
if isfield(opts,'under'); else; opts.under = 1; end %parameter that defines undershoot
if isfield(opts,'pad'); else; opts.pad = 1; end %pad before fft
if isfield(opts,'padfront'); else; opts.padfront = 1; end %pad before fft
if isfield(opts,'detrendHRF'); else; opts.detrendHRF = 0; end %pad before fft

input_probe = rescale(probe);
if opts.pad
    pad = 2^nextpow2(length(probe));
else
    pad = 0;
end
if opts.padfront && opts.pad
    probe = zeros(length(input_probe)+pad,1);
    probe(1:pad) = input_probe(1,1);
    probe(pad+1:end,1) = input_probe;
else
    probe = zeros(length(input_probe)+2*pad,1);
    probe(1:pad) =  input_probe(1,1);
    probe(pad+1:end-pad,1) = input_probe;
    probe(end-pad+1:end,1) =  input_probe(1,end);
end

%generate onset HRFs
nn=0;HRFon = []';

xdata = (1:1:length(probe));
%can also do in terms of TR, but then opts.disp should also be normalized
%by TR.
%xdata = (opts.TR:opts.TR:opts.TR*length(probe));

for ii = 1:length(opts.onset) %onset
    nn = nn+1;
    t = (0:1:length(xdata)-1);
    h_final = zeros(length(t),1);
    alpha_1 = opts.onset(ii);
    beta_1 = 1;
    alpha_2 = alpha_1;
    beta_2 = 1;
    h = ((t.^(alpha_1 - 1)).*(((beta_1).^(-alpha_1)).*(exp((1./(-beta_1)).*t))))./(gamma(alpha_1));
    h2 = ((t.^(alpha_2 - 1)).*(((beta_2).^(-alpha_2)).*(exp((1./(-beta_2)).*t))))./(opts.rratio.*gamma(alpha_2));
    h_onset = h - h2;
    h_onset = h_onset./trapz(h_onset);
    HRFon(nn,:) = h_onset;

end


for jj=1:length(opts.disp)  %skips the first set to make space for the original probe
    HRFdsp(jj,:) = exp(-xdata/(opts.disp(jj)));
end

%first convolve onset HRF with probe then continue with dispersion
% convolve HRF with probe
HRF = zeros([(length(opts.disp)+1)+length(opts.disp)*length(opts.onset) length(probe)]);
idx = zeros([(length(opts.disp)+1)*nn+1 3]);
newprobe_freq = fftshift(fft(probe)/trapz(probe));
mm = length(opts.disp);
for ii=1:size(HRFon,1)
    HRFon_freq = fftshift(fft(HRFon(ii,:)/trapz(HRFon(ii,:))));
    tmp = real(ifft(ifftshift(HRFon_freq(1,end:-1:1).*newprobe_freq')));
    onset = (tmp/trapz(tmp)); %normalize HRF
    onfreq = fftshift(fft(onset)/trapz(probe));
    
    for jj=1:length(opts.disp)  %skips the first set to make space for the original probe
        HRF_freq = fftshift(fft(HRFdsp(jj,:)/trapz(HRFdsp(jj,:))));
        tmp = real(ifft(ifftshift(HRF_freq(1,end:-1:1).*onfreq)));
        tmp2 = (tmp/trapz(tmp)); %normalize HRF
        HRF(ii*mm+jj+1,:) =  tmp2(1,end:-1:1);
        idx(ii*mm+jj+1,:,:,:) = [ii jj 1];
        
    end
end
%add original probe dispersions (i.e. zero onset)
for jj=1:length(opts.disp)%skips the first set to make space for the original probe
    HRF_freq = fftshift(fft(HRFdsp(jj,:)/trapz(HRFdsp(jj,:))));
    tmp = real(ifft(ifftshift(HRF_freq(1,end:-1:1).*newprobe_freq')));
    tmp2 = (tmp/trapz(tmp)); %normalize HRF
    HRF(jj+1,:) =  tmp2(1,end:-1:1);
    idx(jj+1,:,:,:) = [0 jj 1];
end


idx(1,:,:,:) = [1 1 1];
HRF(1,:) = probe/trapz(probe);
HRF_probe = HRF; HRFidx = idx; clear HRF idx;
if opts.padfront && opts.pad
    HRF_probe(:,1:pad) = [];
else
    HRF_probe(:,1:pad) = []; HRF_probe(:,end-pad+1:end) = [];  %remove padding
end

% remove linearly independent components
[Xsub,idx]=licols(HRF_probe', 1e-10);
XHRFidx = HRFidx(idx,:);
HRF_probe = Xsub';
HRFidx = XHRFidx;

%remove artificial trend
if opts.detrendHRF
    %use first and last 10% of data pts (improve this later)
    HRF_probe = detrendHRF(HRF_probe, [50 size(HRF_probe,2)-20]);
end
for ii=1:size(HRF_probe,1); HRF_probe(ii,:) = rescale(HRF_probe(ii,:)); end
if opts.verbose
    figure;
    
    if size(HRF_probe,1) == 1
        customMap = colormap(viridis(128));
    else
        customMap = colormap(flip(brewermap(size(HRF_probe,1),'Spectral')));
    end
    
    for ii=1:size(HRF_probe,1)
        plot(HRF_probe(ii,:)', 'Color', customMap(ii,:)); xlim([0 size(HRF_probe,2)]); hold on;
    end
    plot( HRF_probe(1,:), 'k', 'LineWidth', 2);  title('HRF probe');
    set(gcf, 'Units', 'pixels', 'Position', [200, 500, 600, 160]);
    if isfield(opts,'figdir')
        saveas(gcf,[opts.figdir,'HRF_fnc.fig']);
    else
        if ispc
            saveas(gcf,[pwd,'\','HRF_fnc.fig']);
        else
            saveas(gcf,[pwd,'/','HRF_fnc.fig']);
        end
    end
end